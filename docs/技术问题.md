# <div align="center">cpp</div>

## 1. memory

> #include<memory>

### unique_ptr

​	`std::unique_ptr`是C++11引入的智能指针类型，用于**独占地**管理动态分配的对象，他确保对象在不再需要时自动释放内存，避免内存泄漏。

* **独占所有权**：`std::unique_ptr`独占所管理对象的所有权，不能被复制，只能被移动(``std::move``)
* **自动内存管理**：超出作用域时销毁
* **轻量级**：`std::unique_ptr`仅包含一个指针

​	声明`unique_ptr`类型的变量：

```c++
std::unique_ptr<T> a; // 创建一个空变量
```

​	创建`unique_ptr`类型的变量：**std::make_unique(推荐, C++14)/new**

```cpp
std::unique_ptr<T> a = std::make_unique<T>();
//或者使用auto来自动推断变量类型
auto a = std::make_unique<T>();
```

### make_unique

​	用来创建`unique_ptr`，C++14

### move

​	在使用 `std::unique_ptr` 时，`std::move` 用于转移所有权。由于 `std::unique_ptr` 独占所管理对象的所有权，它不能被复制，但可以被移动。`std::move` 将一个 `std::unique_ptr` 的所有权从一个对象转移到另一个对象。

​	几个需要进行move的场景：

* **函数返回值**：当一个函数返回一个`std::unique_ptr`，使用`std::move()`将所有权**转移给返回值**
* **函数参数按值传递**(与之相对的是按引用传递)：当函数接受一个`std::unique_ptr`参数时，需要使用`std::move()`将所有权转移给参数
* **容器操作**：将`std::unique`插入到容器时，需要使用`std::move()`
* **所有权转移(赋值)**：将`unique_ptr`所有权从一个变量转移到另一个变量时，需要使用`std::move()`

## 2. variant

​	`std::variant` 是 C++17 引入的一个类型安全的联合体，它可以存储多个类型中的一个。它类似于 `std::union`，但提供了更强的类型安全性和更丰富的功能。

